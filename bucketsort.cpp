/*
   Асимптотика Bucket Sort

   Временная сложность:
   1. Разбиение элементов на бакеты — это операция за время O(n), где n — количество элементов в массиве.
      Элементы разбиваются по индексам, которые рассчитываются как произведение значения элемента на количество бакетов.
   2. Сортировка каждого бакета происходит с использованием сортировки вставками, которая имеет временную сложность O(k^2) для каждого бакета, где k — количество элементов в бакете.
      Однако, в худшем случае, все элементы могут попасть в один бакет, что приведет к использованию сортировки вставками для всех элементов, что дает сложность O(n^2).
   3. Объединение всех бакетов в один массив также требует O(n) времени.

   Итого, общая временная сложность:
   - Худшая временная сложность: O(n * k), если все элементы попадают в один бакет, можно n^2(т.к. сортировка вставками может пройтись по всем элементам)
   - Средняя временная сложность: O(n * k), где k —  количество элементов в бакете.
   - Лучшая временная сложность: O(n), Лучший случай происходит, когда каждый блок получает одинаковое количество элементов.
   - В этом случае каждый вызов сортировки вставкой будет занимать постоянное время, поскольку количество элементов в каждом блоке будет постоянным (предполагая, что k линейно пропорционально n).
   - То есть значением k мы можем пренебречь

   Пространственная сложность:
   - Пространственная сложность алгоритма сортировки по бакетам составляет O(n * k), где n — количество элементов в массиве, а k — количество бакетов. Пространственная сложность зависит от размера массива и количества бакетов.

   Итого:
   - Временная сложность: O(n^2) (в худшем случае), O(n * k) (в лучшем случае)
   - Пространственная сложность: O(n * k)
   */

#include <iostream>
#include <vector>
#include <cassert>

float findMin(const std::vector<float> &array) {
    float min = array[0];
    for (size_t i = 1; i < array.size(); ++i) {
        if (array[i] < min) min = array[i];
    }
    return min;
}

float findMax(const std::vector<float> &array) {
    float max = array[0];
    for (size_t i = 1; i < array.size(); ++i) {
        if (array[i] > max) max = array[i];
    }
    return max;
}

// Используем сортировку вставками для ВСТАВКИ значения в бакет
void insertionSort(std::vector<float> &bucket) {
    for (size_t i = 1; i < bucket.size(); ++i) {
        float key = bucket[i];
        int j = i - 1;
        while (j >= 0 && bucket[j] > key) {
            bucket[j + 1] = bucket[j];
            --j;
        }
        bucket[j + 1] = key;
    }
}

// Функция сортировки бакетом
void bucketSort(std::vector<float> &array) {
    // Находим минимальное и максимальное значения в массиве
    // Это нужно для того, чтобы правильно распределить элементы по бакетам.
    float min = findMin(array);
    float max = findMax(array);

    // Количество бакетов (корзин) зависит от количества элементов в массиве
    // Например, если у нас 10 элементов, создадим 10 бакетов.
    // Можно изменить на любое другое количество бакетов, например, n / 2 или n / 10
    int bucketCount = array.size();  // В данном случае количество бакетов = количеству элементов в массиве

    // Создаем бакеты (корзины) — это массив из векторов
    // Каждый бакет будет хранить значения, которые попадают в его диапазон.
    std::vector<float> buckets[bucketCount];

    // Разделяем элементы массива на бакеты (корзины)
    for (size_t i = 0; i < array.size(); ++i) {
        // Рассчитываем индекс для текущего элемента, который будет определять, в какой бакет его поместить.
        // Индекс зависит от разницы между значением элемента и минимальным значением,
        // а также от диапазона возможных значений (от min до max).
        int index = (array[i] - min) * (bucketCount - 1) / (max - min);

        // Помещаем элемент в соответствующий бакет
        // Здесь индекс бакета зависит от значения элемента.
        buckets[index].push_back(array[i]);
    }


    // Сортируем каждый бакет с помощью сортировки вставками
    // В зависимости от того, сколько элементов в каждом бакете, используется сортировка вставками.
    // Это происходит, потому что в большинстве случаев количество элементов в бакете
    // будет небольшим (что делает сортировку вставками эффективной).
    for (int i = 0; i < bucketCount; ++i) {
        // Если бакет не пустой, сортируем его
        if (!buckets[i].empty()) {
            insertionSort(buckets[i]);  // Сортировка вставками для каждого бакета
        }
    }

    // Собираем отсортированные элементы обратно в массив
    // После того как все бакеты отсортированы, объединяем их в один отсортированный массив.
    size_t index = 0;
    for (int i = 0; i < bucketCount; ++i) {
        for (size_t j = 0; j < buckets[i].size(); ++j) {
            // Сначала заполняем исходный массив отсортированными элементами
            array[index++] = buckets[i][j];
        }
    }
}


// Напишем вспомогательную функцию, которая проверяет отсортирован ли массив.
bool isSorted(const std::vector<float> &array) {
    for (size_t i = 1; i < array.size(); i++) {
        if (array[i - 1] > array[i]) {
            return false;
        }
    }
    return true;
}

void runTests() {
    // Худший случай с 50 элементами, близкими по значению, чтобы они попали в один бакет
    std::vector<float> testarray(50, 100.0); // Заполняем вектор значениями около 100.0
    for (size_t i = 0; i < testarray.size(); ++i) {
        testarray[i] +=
                i * 0.001; // Небольшое отклонение, чтобы элементы не были одинаковыми(иначе какой смысл в сортировке)
    }
    bucketSort(testarray);
    assert(isSorted(testarray));

    // Худший случай (все элементы попадут в 1 бакет)
    std::vector<float> worstCase = {1.001, 1.002, 1.003, 1.004, 1.005, 1.006, 1.007, 1.008, 1.009, 1.010};
    bucketSort(worstCase);
    assert(isSorted(worstCase));

    // Средний случай (все элементы распределены равномерно по бакетам)
    std::vector<float> averageCase = {0.25, 0.75, 0.5, 1.25, 1.75, 1.5, 2.25, 2.75, 2.5, 3.0};
    bucketSort(averageCase);
    assert(isSorted(averageCase));

    // Лучший случай (для каждого элемента будет создан свой бакет и не придется ничего сортировать)
    std::vector<float> bestCase = {0.1, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5};
    bucketSort(bestCase);
    assert(isSorted(bestCase));

    std::cout << "All tests passed successfully!" << std::endl;
}

int main() {
    runTests();

    int n;
    std::cout << "Enter the number of elements: ";
    std::cin >> n;

    std::vector<float> array(n);
    std::cout << "Enter elements:\n";
    for (int i = 0; i < n; ++i) {
        std::cin >> array[i];
    }


    bucketSort(array);

    std::cout << "Sorted array: \n";
    for (size_t i = 0; i < n; ++i) {
        std::cout << array[i] << " ";
    }
    std::cout << std::endl;

    return 0;
}
