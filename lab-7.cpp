class Solution {
public:
    int maxSatisfaction(vector<int>& satisfaction) {
        int n = satisfaction.size(); // O(1) по времени, O(1) по памяти
        // Сортировка для определения самых удовлетворительных блюд.
        sort(satisfaction.begin(),satisfaction.end()); // O(N log N) по времени, O(log N) по памяти (в большинстве реализаций std::sort)
        // Мы будем готовить все самые удовлетворительные блюда, пока
        // не найдем блюдо, настолько плохое, что оно сделает общее
        // удовлетворение от приготовленных до сих пор блюд отрицательным,
        // т.е. худшее удовлетворение будет достигнуто, если мы возьмем это блюдо, поэтому выходим из цикла.
        int result=0,total=0; // O(1) по времени, O(1) по памяти
        for(int dish=n-1;dish>=0;--dish){ // O(N) по времени
            if(satisfaction[dish]+total<0){ // O(1) по времени
                // Встречено самое плохое блюдо.
                break; // O(1) по времени
            }else{ // O(1) по времени
                total+=satisfaction[dish]; // O(1) по времени
                result+=total; // O(1) по времени
            }
        }
        return result; // O(1) по времени, O(1) по памяти
    }
};
// O(N log N) - общая временная сложность, O(log N) - память