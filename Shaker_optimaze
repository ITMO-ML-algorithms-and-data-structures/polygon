#include <iostream>
#include <vector>
#include <fstream>

#include <chrono>

#include <random>

#include <future>

// Функция сортировки шейкер-сортом
void shakerSort(std::vector<int>& arr) {
    int left = 0;
    int right = arr.size() - 1;
    bool swapped = true;

    while (left < right && swapped) {
        swapped = false;

        // Проход слева направо
        for (int i = left; i < right; i++) {
            if (arr[i] > arr[i + 1]) {
                std::swap(arr[i], arr[i + 1]);
                swapped = true;
            }
        }
        right--;

        // Проход справа налево
        for (int i = right; i > left; i--) {
            if (arr[i] < arr[i - 1]) {
                std::swap(arr[i], arr[i - 1]);
                swapped = true;
            }
        }
        left++;
    }
}

// Функция для генерации массива случайных чисел
std::vector<int> generateRandomArray(int size) {
    std::vector<int> arr(size);
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(0, 10000);

    for (int i = 0; i < size; ++i) {
        arr[i] = dis(gen);
    }
    return arr;
}

// Функция для измерения времени сортировки
double measureSortTime(std::vector<int>& arr) {
    auto start = std::chrono::high_resolution_clock::now();
    shakerSort(arr);
    auto end = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> duration = end - start;
    return duration.count();
}

// Функция, которая генерирует массив и измеряет время сортировки
void processArrayAndSaveTime(int size, const std::string& outputFile) {
    // Генерация массива
    std::vector<int> arr = generateRandomArray(size);

    // Измерение времени сортировки
    double duration = measureSortTime(arr);

    // Запись времени выполнения в файл
    std::ofstream outFile(outputFile, std::ios::app);
    if (outFile.is_open()) {
        outFile << size << " " << duration << "\n";
        outFile.close();
    } else {
        std::cerr << "Не удалось открыть файл для записи!" << std::endl;
    }
}

// Функция для параллельной обработки массивов
void processArraysInParallel(int numArrays, const std::string& outputFile) {
    std::vector<std::future<void>> futures;

    for (int i = 1; i <= numArrays; ++i) {
        int size = i * 1000; // Размер массива = i * 1000
        futures.push_back(std::async(std::launch::async, processArrayAndSaveTime, size, outputFile));

        // Ограничиваем количество параллельных потоков (например, 4 потока одновременно)
        if (futures.size() >= 4) {
            for (auto& fut : futures) {
                fut.get(); // Ждем завершения всех потоков
            }
            futures.clear(); // Очищаем список
        }
    }

    // Ждем завершения всех оставшихся потоков
    for (auto& fut : futures) {
        fut.get();
    }
}

int main() {
    std::string outputFile = "C:\\Users\\R1300-W-1-Stud\\Documents\\shaker_sort_times.txt";

    // Запуск параллельной обработки массивов
    processArraysInParallel(1000, outputFile);

    std::cout << "Обработка завершена. Результаты записаны в файл: " << outputFile << std::endl;

    return 0;
}
