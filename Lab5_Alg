#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>
#include <chrono>
#include <climits>
#include <fstream>
#include <string>

// Функция сортировки коктейльной встряхиванием (Cocktail Shaker Sort)
void cocktailShakerSort(std::vector<int>& arr) {
    bool swapped = true; // O(1) - флаг для отслеживания обменов
    int start = 0; // O(1) - начало рассматриваемого диапазона
    size_t end = arr.size() - 1; // O(1) - конец рассматриваемого диапазона

    // Внешний цикл, выполняется, пока есть обмены
    while (swapped) { // O(n) в лучшем случае, O(n^2) в худшем случае
        swapped = false; // O(1) - сброс флага перед новым проходом

        // Прямой проход: от начала к концу
        for (int i = start; i < end; i++) { // O(n)
            // Если текущий элемент больше следующего, меняем их местами
            if (arr[i] > arr[i + 1]) { // O(1) - сравнение
                std::swap(arr[i], arr[i + 1]); // O(1) - обмен элементов
                swapped = true; // O(1) - установление флага, что был обмен
            }
        }
        if (!swapped) break; // O(1) - проверка флага

        end--; // O(1) - уменьшаем конец диапазона

        swapped = false; // O(1) - сброс флага для обратного прохода

        // Обратный проход: от конца к началу
        for (int i = end; i > start; --i) { // O(n)
            // Если текущий элемент меньше предыдущего, меняем их местами
            if (arr[i] < arr[i - 1]) { // O(1) - сравнение
                std::swap(arr[i], arr[i - 1]); // O(1) - обмен элементов
                swapped = true; // O(1) - установление флага, что был обмен
            }
        }
        start++; // O(1) - увеличиваем начало диапазона
    }
}

/*
  Временная сложность:
  - В худшем случае (обратный порядок): O(n^2), так как каждый элемент может быть перемещен
    во время каждого прохода.
  - В лучшем случае (уже отсортированный массив): O(n) за один проход без обменов.
  - В среднем случае: O(n^2), учитывая, что массив случайно перемешан.

  Пространственная сложность: O(1), используется только несколько переменных для хранения
  текущего состояния и флагов.
*/

// Функция для перестройки поддерева в кучу (heap)
void heapify(std::vector<int>& arr, int n, int i) {
    int largest = i; // O(1) — инициализация корня как самого большого элемента
    int left = 2 * i + 1; // O(1) — индекс левого дочернего элемента
    int right = 2 * i + 2; // O(1) — индекс правого дочернего элемента

    // Проверяем, если левый дочерний элемент больше корня
    if (left < n && arr[left] > arr[largest]) { // O(1)
        largest = left; // O(1)
    }

    // Проверяем, если правый дочерний элемент больше текущего самого большого элемента
    if (right < n && arr[right] > arr[largest]) { // O(1)
        largest = right; // O(1)
    }

    // Если самый большой элемент не корень, меняем местами
    if (largest != i) { // O(1)
        std::swap(arr[i], arr[largest]); // O(1) - обмен значениями
        heapify(arr, n, largest); // O(log n) - рекурсивный вызов
    }
}

/*
  Временная сложность heapify:
  - O(log n) в среднем и худшем случае, так как может быть выполнено до log(n) рекурсивных вызовов
  - O(1) в лучшем случае, если элементы уже расположены правильно (например, когда самый большой элемент является корнем)

  Пространственная сложность: O(1) — используется лишь несколько переменных для хранения состояния.
*/

void heapSort(std::vector<int>& arr) {
    size_t n = arr.size(); // O(1) — получаем размер массива

    // Построение кучи (перестройка массива в max-heap)
    for (int i = n / 2 - 1; i >= 0; i--) { // O(n)
        heapify(arr, n, i); // O(log n)
    }
    // Один за другим извлекаем элементы из кучи
    for (int i = n - 1; i >= 0; i--) { // O(n)
        // Перемещаем текущий корень (максимальный элемент) в конец
        std::swap(arr[0], arr[i]); // O(1)
        heapify(arr, i, 0); // O(log n)
    }
}

/*
  Временная сложность heapSort:
  - O(n log n) в худшем и среднем случае, так как построение кучи (n/2 вызовов heapify)
    занимает O(n) и каждая перестройка биов составляет O(log n).
  - O(n log n) в лучшем случае (уже отсортирована), так как нужно пройти все элементы.

  Пространственная сложность: O(1) — не используются дополнительные массивы.
*/

// Функция для сортировки по карманам (Pigeonhole Sort)
void pigeonholeSort(std::vector<int>& arr) {
    size_t n = arr.size(); // O(1) — получаем размер массива
    if (n <= 0) return; // O(1) — если массив пуст, выходим

    // Находим минимальное и максимальное значения в массиве
    int min_value = *std::min_element(arr.begin(), arr.end()); // O(n) — нахождение минимального элемента
    int max_value = *std::max_element(arr.begin(), arr.end()); // O(n) — нахождение максимального элемента

    int range = max_value - min_value + 1; // O(1) — диапазон значений
    std::vector<std::vector<int>> pigeonholes(range); // O(range) — создание вектора карманов

    // Размещаем элементы в соответствующие карманы
    for (int i = 0; i < n; i++) { // O(n)
        pigeonholes[arr[i] - min_value].push_back(arr[i]); // O(1)
    }

    // Собираем элементы обратно в исходный массив
    int index = 0; // O(1)
    for (int i = 0; i < range; i++) { // O(range)
        for (int j = 0; j < pigeonholes[i].size(); j++) { // O(k), где k — количество элементов в кармане
            arr[index] = pigeonholes[i][j]; // O(1)
            index++; // O(1)
        }
    }
}

/*
  Временная сложность:
  - O(n) для поиска минимального и максимального элемента.
  - O(n + range) для размещения элементов в карманы и сбора их обратно.
  - В общем случае: O(n + range), где n — количество элементов, а range — диапазон значений.
  - Если элементы имеют большой диапазон, может потребоваться много памяти, но незначительное количество операций.

  Пространственная сложность: O(range), поскольку мы создаем массив карманов, который зависит от диапазона возможных значений.
*/

void printArray(const std::vector<int>& arr) {
    for (int num : arr) { // O(n)
        std::cout << num << " "; // O(1)
    }
    std::cout << std::endl; // O(1)
}

// Универсальная функция для тестирования любой сортировки
void runTests(void (*sortFunction)(std::vector<int>&)) {
    // Тест: лучший случай
    {
        std::vector<int> arr = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
        std::vector<int> expected = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; // O(n)
        std::cout << "Исходный массив (лучший случай): ";
        printArray(arr);
        sortFunction(arr);
        assert(arr == expected); // O(n)
        std::cout << "Отсортированный массив: ";
        printArray(arr);
        std::cout << "Тест 1 (Лучший случай) прошел." << std::endl << std::endl;
    }

    // Тест: средний случай
    {
        std::vector<int> arr = { 8, 3, 5, 2, 7, 1, 4, 6 };
        std::vector<int> expected = { 1, 2, 3, 4, 5, 6, 7, 8 }; // O(n)
        std::cout << "Исходный массив (средний случай): ";
        printArray(arr);
        sortFunction(arr);
        assert(arr == expected); // O(n)
        std::cout << "Отсортированный массив: ";
        printArray(arr);
        std::cout << "Тест 2 (Средний случай) прошел." << std::endl << std::endl;
    }

    // Тест: худший случай
    {
        std::vector<int> arr = { 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 };
        std::vector<int> expected = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; // O(n)
        std::cout << "Исходный массив (худший случай): ";
        printArray(arr);
        sortFunction(arr);
        assert(arr == expected); // O(n)
        std::cout << "Отсортированный массив: ";
        printArray(arr);
        std::cout << "Тест 3 (Худший случай) прошел." << std::endl << std::endl;
    }

    std::cout << "Все тесты пройдены!" << std::endl;
}

// Структура для хранения результатов сортировки
struct SortResult {
    std::string algorithm; // Название алгоритма
    size_t arraySize;      // Размер массива
    double elapsedTime;    // Время сортировки
};

int main() {
    setlocale(LC_ALL, "Ru");
    
    std::cout << "Тестирование сортировки коктейльной встряхиванием:" << std::endl;
    runTests(cocktailShakerSort);
    
    std::cout << "\nТестирование сортировки кучей (Heap Sort):" << std::endl;
    runTests(heapSort);
    
    std::cout << "\nТестирование сортировки по карманам (Pigeonhole Sort):" << std::endl;
    runTests(pigeonholeSort);
    
    return 0;
}
