/***** 1402. Reducing dishes *****/
#include <iostream>
#include <vector>

/*** Часть 1. Quick Sort по убыванию ***/
// Функция, делящая массив
int partition(std::vector<int>& arr, int low, int high) { // 4 + 4 байта на два int, 24 байта на вектор
    // Выбираем опорный элемент (последний) и индекс меньшего элемента
    int pivot = arr[high]; // O(1). +4 байта на int
    int i = low - 1; // O(1). +4 байта на int

    // Проход по всем от low до high-1
    for (int j = low; j < high; j++) { // O(N), N - разность между high и low. +4 байта на int
        // Сравниваем текущий с опорным, если текущий больше, то увеличиваем индекс i и меняем местами i и j
        if (arr[j] > pivot) { // O(1)
            i++; // O(1)
            std::swap(arr[i], arr[j]); // O(1)
        }
    }
    // Меняем местами опорный элемент с элементом после последнего меньшего, и возвращаем индекс опорного
    std::swap(arr[i + 1], arr[high]); // O(1)
    return i + 1; // O(1)
}
// Итог по функции partition: O(N), где N - разность между hight и low

// Основная функция для Quick Sort
void quick_sort(std::vector<int>& arr, int low, int high) { // + 4 + 4 байта на два int, +24 байта на вектор
    if (low < high) { // O(1)
        // Делим массив и получаем индекс опорного
        int pi = partition(arr, low, high); // O(N), вызов partition. +4 байта на int

        // Рекурсивно сортируем элементы в левой и правой частях
        quick_sort(arr, low, pi - 1); // O(logN) в среднем случае, рекурсия
        quick_sort(arr, pi + 1, high); // O(logN) в среднем случае
    }
}
// Итог по функции quick_sort: O(N * logN) в среднем случае. В худшем может достигать O(N^2)


/*** Часть 2. Решение задачи ***/
// Функция, принимающая набор коэффициентов блюд и возвращающая оптимальный итог по ним
int maxSatisfaction(std::vector<int>& satisfaction) { // +24 байта на вектор
    // Задаём итоговую сумму, она состоит из слагаемых вида time*coef, то есть коэффициент блюда на время его готовки (по условию n-ное блюдо готовится n единиц времени, отсчёт n ведётся с 1)
    // Задаём сумму коэффициентов, в неё будем добавлять коэффициенты тех блюд, которые будут приготовлены
    int res_sum = 0; // O(1). +4 байта на int
    int satisfaction_sum = 0; // O(1). +4 байта на int
    // Сортируем коэффициенты по убыванию, чтобы сначала учесть наилучшие блюда
    quick_sort(satisfaction, 0, satisfaction.size()-1); // O(N * logN), вызов сортировки

    // Начинаем перебирать от лучшего к худшему
    for (int& sat_coef : satisfaction) { // O(N), проход по всем элементам
        // Прибавляем коэф к их текущей сумме
        satisfaction_sum += sat_coef; // O(1)
        // Если в какой-то момент оказалось, что на следующем блюде мы уже не получим значение больше, то дальше продолжать не нужно и лучший результат мы уже получили
        // Если сумма положительная, то можем добавить еще блюдо, его мы добавляем в начало очереди, тогда к результату прибавится сумма всех коэффициентов (время готовки каждого прошлого увеличится на 1) и добавится новое блюдо с временем 1
        if (satisfaction_sum <= 0) { // O(1)
            return res_sum; // O(1)
        } else {
            res_sum += satisfaction_sum; // O(1)
        }
    }
    // Если прошлись по всем блюдам и return еще не было, то делаем return
    return res_sum; // O(1)
}
// Итог по maxSatisfaction: O(N * logN) в среднем случае. Фактически итоговая сложность будет зависеть от выбранной сортировки, тк основной «вклад» в сложность вносит именно она