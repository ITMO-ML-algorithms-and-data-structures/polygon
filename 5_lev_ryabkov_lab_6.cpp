#include <iostream>
#include <vector>
#include <climits>
using namespace std;

class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();  // Переменная n: 4 байта // O(1)
        if (n == 0) return 0;  // Проверка: O(1)

        int k = 2;  // Константа k: 4 байта // O(1)
        vector<vector<int>> dp(k + 1, vector<int>(n, 0));
        // dp: 24 байта (объект вектора) + (k + 1) * n * 4 байта = (3 * n + 24) байта // O(k * n)

        for (int t = 1; t <= k; ++t) {  // Переменная t: 4 байта // O(k)
            int maxDiff = -prices[0];  // Переменная maxDiff: 4 байта // O(1)
            for (int i = 1; i < n; ++i) {  // Переменная i: 4 байта // O(n)
                dp[t][i] = max(dp[t][i - 1], prices[i] + maxDiff);
                // Доступ по индексу: O(1), операции max: O(1)
                maxDiff = max(maxDiff, dp[t - 1][i] - prices[i]);
                // Доступ по индексу: O(1), операции max: O(1)
            }
        }

        return dp[k][n - 1];  // Доступ по индексу: O(1)
        // Итоговая сложность для основного тела функции: O(k * n)
    }
};

// Подсчет памяти:
// 1. n: 4 байта
// 2. k: 4 байта
// 3. maxDiff: 4 байта
// 4. Переменные цикла (t, i): 2 * 4 = 8 байт
// 5. Вектор dp:
//    - Объект вектора: 24 байта
//    - Размер данных: (k + 1) * n * 4 байта = 3 * n * 4 байта (для k = 2)
// Общая память: ~ 24 байта (вектор) + 12 байт (переменные) + 3 * n * 4 байта = (12 + 3 * n * 4) байт

// Подсчет сложности:
// 1. Внешний цикл по t: O(k), где k — фиксированное количество транзакций (k = 2)
// 2. Вложенный цикл по i: O(n)
// 3. Операции в теле вложенного цикла: O(1)
// Итоговая сложность: O(k * n)

// Пример для k = 2 и n элементов в prices:
// - Пространственная сложность: O(n) (за счет вектора dp)
// - Временная сложность: O(2 * n) = O(n)