#include <string>
#include <vector>
#include <algorithm>

class Solution {
public:
    int longestValidParentheses(std::string s) {
        // Подсчет по памяти:
        // Использую переменную length для хранения длины входной строки s. Это O(1).
        // Далее создаю вектор validLengths длиной length + 1, чтобы отслеживать длину корректных подстрок.
        // Память для этого вектора равна O(n), где n - длина строки s.
        // Итого: O(n) на память.

        int length = s.size();
        std::vector<int> validLengths(length + 1, 0); // Инициализируем вектор нулями (O(n))

        // Подсчет асимптотики:
        // Внешний цикл for выполняется n - 1 раз (от 2 до length), то есть O(n).
        // Вложенный код выполняет несколько операций с присвоениями, которые также выполняются за O(1).
        // Таким образом, время выполнения основного цикла составляет O(n).

        for (int i = 2; i <= length; ++i) {
            if (s[i - 1] == ')') { // Проверка текущего символа
                if (s[i - 2] == '(') { // Проверка на корректную пару "()"
                    validLengths[i] = validLengths[i - 2] + 2; // Обновление длины корректной подстроки
                }
                else {
                    // Попытка найти соответствующую открывающую скобку для текущей закрывающей
                    int matchingOpenIndex = i - validLengths[i - 1] - 1; // Вычисление индекса
                    if (matchingOpenIndex > 0 && s[matchingOpenIndex - 1] == '(') {
                        // Нашлась корректная пара через другую вложенную структуру
                        validLengths[i] = validLengths[i - 1] + 2 + validLengths[matchingOpenIndex - 1];
                    }
                }
            }
        }

        // Возвращает максимальное значение, которое обозначает длину самой длинной корректной подстроки
        // std::max_element проходит по вектору validLengths, что требует O(n) времени.
        return *std::max_element(validLengths.begin(), validLengths.end());
    }
};

// Динамическое программирование подходит для этой задачи,
// поскольку мы можем разбить задачу на более мелкие подзадачи,
// вычисляя длину корректных подстрок постепенно.
// Каждый шаг использует результаты предыдущих вычислений,
// что позволяет избежать повторных проверок и делает процесс более эффективным.
// Время и пространство оптимизированы, что делает этот подход особенно эффективным для работы со строками и вложенными структурами.
